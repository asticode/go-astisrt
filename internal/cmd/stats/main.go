package main

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"text/template"
	"unicode"
)

const version = "v1.5.0"

var r1 = regexp.MustCompile(`struct CBytePerfMon\n\{([^\}]*)`)
var r2 = regexp.MustCompile(`[\s]*([\w]+)[\s]*([\w]+);`)

type stat struct {
	Name string
	Type string
}

func capitalize(s string) string {
	if len(s) == 0 {
		return ""
	}
	r := []rune(s)
	return string(append([]rune{unicode.ToUpper(r[0])}, r[1:]...))
}

func (s stat) GoName() string {
	return capitalize(s.Name)
}

func (s stat) GoType() string {
	switch s.Type {
	case "int64_t":
		return "int64"
	case "int":
		return "int"
	case "uint64_t":
		return "uint64"
	case "double":
		return "float64"
	}
	return "unknown"
}

var tpl = `// Code generated by astisrt using internal/cmd/wrap. DO NOT EDIT.
package astisrt

// #cgo LDFLAGS: -lsrt
// #include <srt/srt.h>
import "C"

type Stats struct {
	c C.SRT_TRACEBSTATS
}

func (s *Socket) Stats(clear, instantaneous bool) (ss Stats, err error) {
	err = cBiStats(s.u, &ss.c, boolToCInt(clear), boolToCInt(instantaneous))
	return
}

{{ range $stat := . }}
func (ss Stats) {{ $stat.GoName }}() {{ $stat.GoType }} {
	return {{ $stat.GoType }}(ss.c.{{ $stat.Name }})
}
{{ end }}`

func main() {
	dir, err := os.Getwd()
	if err != nil {
		log.Fatal(fmt.Errorf("main: getting working directory failed: %w", err))
	}

	ss, err := stats(dir)
	if err != nil {
		log.Fatal(fmt.Errorf("main: getting stats failed: %w", err))
	}

	log.Println("generating stats.go")

	f, err := os.Create(filepath.Join(dir, "pkg", "stats.go"))
	if err != nil {
		log.Fatal(fmt.Errorf("main: creating file failed: %w", err))
	}
	defer f.Close()

	if err = template.Must(template.New("tmpl").Parse(tpl)).Execute(f, ss); err != nil {
		log.Fatal(fmt.Errorf("main: executing template failed: %w", err))
	}
}

func stats(dir string) (ss []stat, err error) {
	// Read header
	var b []byte
	if b, err = ioutil.ReadFile(filepath.Join(dir, "tmp", version, "include", "srt", "srt.h")); err != nil {
		err = fmt.Errorf("main: reading header failed: %w", err)
		return
	}

	// Match
	matches := r1.FindAllSubmatch(b, -1)
	if len(matches) < 1 || len(matches[0]) < 2 {
		err = errors.New("main: invalid matches size")
		return
	}

	// Scan
	s := bufio.NewScanner(bytes.NewBuffer(matches[0][1]))
	for s.Scan() {
		// Match
		matches := r2.FindAllSubmatch(s.Bytes(), -1)
		if len(matches) < 1 || len(matches[0]) < 3 {
			continue
		}

		// Add stat
		ss = append(ss, stat{
			Name: string(matches[0][2]),
			Type: string(matches[0][1]),
		})
	}
	return
}

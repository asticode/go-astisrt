package main

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"text/template"
	"unicode"
)

const version = "v1.5.3"

var r1 = regexp.MustCompile(`struct CBytePerfMon\n\{([^\}]*)`)
var r2 = regexp.MustCompile(`[\s]*([\w]+)[\s]*([\w]+);`)

type stat struct {
	Name string
	Type string
}

func capitalize(s string) string {
	if len(s) == 0 {
		return ""
	}
	r := []rune(s)
	return string(append([]rune{unicode.ToUpper(r[0])}, r[1:]...))
}

func (s stat) GoName() string {
	return capitalize(s.Name)
}

func (s stat) GoType() string {
	switch s.Type {
	case "int64_t":
		return "int64"
	case "int":
		return "int"
	case "uint64_t":
		return "uint64"
	case "double":
		return "float64"
	}
	return "unknown"
}

func (s stat) ExpectedValue() string {
	switch s.Type {
	case "int64_t":
		return "int64(42)"
	case "int":
		return "int(42)"
	case "uint64_t":
		return "uint64(42)"
	case "double":
		return "float64(42)"
	}
	return "unknown"
}

type tpl struct {
	content  string
	filename string
}

var tpls = []tpl{
	{
		content: `// Code generated by astisrt using internal/cmd/generate/stats. DO NOT EDIT.
package astisrt

// #cgo LDFLAGS: -lsrt
// #include <srt/srt.h>
import "C"

type Stats struct {
	c C.SRT_TRACEBSTATS
}

func (s *Socket) Stats(clear, instantaneous bool) (ss Stats, err error) {
	err = cBiStats(s.u, &ss.c, boolToCInt(clear), boolToCInt(instantaneous))
	return
}

{{ range $stat := . }}
func (ss Stats) {{ $stat.GoName }}() {{ $stat.GoType }} {
	return {{ $stat.GoType }}(ss.c.{{ $stat.Name }})
}
{{ end }}`,
		filename: "stats.go",
	},
	{
		content: `// Code generated by astisrt using internal/cmd/generate/stats. DO NOT EDIT.
package astisrt

import (
	"testing"

	"github.com/stretchr/testify/require"
)

func TestStats(t *testing.T) {
	s := Stats{}
	{{ range $stat := . }}s.c.{{ $stat.Name }} = _Ctype_{{ $stat.Type }}({{ $stat.ExpectedValue }})
	require.Equal(t, {{ $stat.ExpectedValue }}, s.{{ $stat.GoName }}())
	{{ end }}
}`,
		filename: "stats_test.go",
	},
}

func main() {
	dir, err := os.Getwd()
	if err != nil {
		log.Fatal(fmt.Errorf("main: getting working directory failed: %w", err))
	}

	ss, err := stats(dir)
	if err != nil {
		log.Fatal(fmt.Errorf("main: getting stats failed: %w", err))
	}

	for _, tpl := range tpls {
		log.Printf("generating %s\n", tpl.filename)

		f, err := os.Create(filepath.Join(dir, "pkg", tpl.filename))
		if err != nil {
			log.Fatal(fmt.Errorf("main: creating file failed: %w", err))
		}
		defer f.Close()

		if err = template.Must(template.New("tmpl").Parse(tpl.content)).Execute(f, ss); err != nil {
			log.Fatal(fmt.Errorf("main: executing template failed: %w", err))
		}
	}
}

func stats(dir string) (ss []stat, err error) {
	// Read header
	var b []byte
	if b, err = os.ReadFile(filepath.Join(dir, "tmp", version, "include", "srt", "srt.h")); err != nil {
		err = fmt.Errorf("main: reading header failed: %w", err)
		return
	}

	// Match
	matches := r1.FindAllSubmatch(b, -1)
	if len(matches) < 1 || len(matches[0]) < 2 {
		err = errors.New("main: invalid matches size")
		return
	}

	// Scan
	s := bufio.NewScanner(bytes.NewBuffer(matches[0][1]))
	for s.Scan() {
		// Match
		matches := r2.FindAllSubmatch(s.Bytes(), -1)
		if len(matches) < 1 || len(matches[0]) < 3 {
			continue
		}

		// Add stat
		ss = append(ss, stat{
			Name: string(matches[0][2]),
			Type: string(matches[0][1]),
		})
	}
	return
}

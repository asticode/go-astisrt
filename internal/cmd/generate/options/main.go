package main

import (
	"bufio"
	"bytes"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
	"unicode"
)

const version = "v1.5.3"

var (
	r1 = regexp.MustCompile("\\[`([\\w]+)`\\]")
	r2 = regexp.MustCompile("`([\\w]+)`")
	r3 = regexp.MustCompile("#### `([\\w]+)`")
)

type enumValue string

func (v enumValue) GoName() string {
	return cNameToCamel(string(v))
}

type enum struct {
	Name   string
	search string
	Type   string
	Values []enumValue
}

func (e enum) GoName() string {
	return cNameToCamel(e.Name)
}

type option struct {
	Dir    string
	goType string
	Name   string
	Type   string
}

func (opt option) HasRead() bool {
	return strings.ContainsRune(opt.Dir, 'R')
}

func (opt option) HasWrite() bool {
	return strings.ContainsRune(opt.Dir, 'W')
}

func capitalize(s string) string {
	if len(s) == 0 {
		return ""
	}
	r := []rune(s)
	return string(append([]rune{unicode.ToUpper(r[0])}, r[1:]...))
}

func cNameToCamel(name string) (o string) {
	for idx, v := range strings.Split(name, "_") {
		if idx == 0 {
			continue
		}
		o += capitalize(strings.ToLower(v))
	}
	return
}

func (opt option) GoFunctionName() string {
	return cNameToCamel(opt.Name)
}

func (opt option) CFunctionName() string {
	t := opt.Go2CType()
	if t == "syscall.Linger" {
		t = "linger"
	}
	return capitalize(t)
}

func (opt option) GoType() string {
	if opt.goType != "" {
		return opt.goType
	}
	return opt.Go2CType()
}

func (opt option) Go2CType() string {
	switch opt.Type {
	case "string":
		return "string"
	case "int32_t":
		return "int32"
	case "int64_t":
		return "int64"
	case "bool":
		return "bool"
	case "linger":
		return "syscall.Linger"
	}
	return "unknown"
}

type data struct {
	Enums   []enum
	Options []option
}

func (d data) ConnectionOptions() (opts []option) {
	for _, opt := range d.Options {
		// Invalid options
		if opt.Name == "SRTO_RCVSYN" || opt.Name == "SRTO_SNDSYN" {
			continue
		}
		opts = append(opts, opt)
	}
	return
}

type tpl struct {
	content  string
	filename string
}

var tpls = []tpl{
	{
		content: `// Code generated by astisrt using internal/cmd/generate/options. DO NOT EDIT.
package astisrt

// #cgo LDFLAGS: -lsrt
// #include <srt/srt.h>
import "C"
import (
	"syscall"
	"unsafe"
)

// https://github.com/Haivision/srt/blob/master/docs/API/API-socket-options.md#list-of-options

type SocketOptions struct {
	s *Socket
}

func (s *Socket) Options() *SocketOptions {
	return &SocketOptions{s: s}
}

func (so *SocketOptions) getInt64(o C.SRT_SOCKOPT) (int64, error) {
	var v int64
	size := int(unsafe.Sizeof(v))
	err := cGetSockFlag(so.s.u, o, unsafe.Pointer(&v), &size)
	return v, err
}

func (so *SocketOptions) getInt32(o C.SRT_SOCKOPT) (int32, error) {
	var v int32
	size := int(unsafe.Sizeof(v))
	err := cGetSockFlag(so.s.u, o, unsafe.Pointer(&v), &size)
	return v, err
}

func (so *SocketOptions) getString(o C.SRT_SOCKOPT) (string, error) {
	buf := make([]byte, 1024)
	size := len(buf)
	err := cGetSockFlag(so.s.u, o, unsafe.Pointer(&buf[0]), &size)
	return string(buf[:size]), err
}

func (so *SocketOptions) getBool(o C.SRT_SOCKOPT) (bool, error) {
	var v bool
	size := int(unsafe.Sizeof(v))
	err := cGetSockFlag(so.s.u, o, unsafe.Pointer(&v), &size)
	return v, err
}

func (so *SocketOptions) getLinger(o C.SRT_SOCKOPT) (syscall.Linger, error) {
	var v syscall.Linger
	size := int(unsafe.Sizeof(v))
	err := cGetSockFlag(so.s.u, o, unsafe.Pointer(&v), &size)
	return v, err
}

func (so *SocketOptions) setInt64(o C.SRT_SOCKOPT, v int64) error {
	return cSetSockFlag(so.s.u, o, unsafe.Pointer(&v), int(unsafe.Sizeof(v)))
}

func (so *SocketOptions) setInt32(o C.SRT_SOCKOPT, v int32) error {
	return cSetSockFlag(so.s.u, o, unsafe.Pointer(&v), int(unsafe.Sizeof(v)))
}

func (so *SocketOptions) setBool(o C.SRT_SOCKOPT, v bool) error {
	return cSetSockFlag(so.s.u, o, unsafe.Pointer(&v), int(unsafe.Sizeof(v)))
}

func (so *SocketOptions) setString(o C.SRT_SOCKOPT, v string) error {
	return cSetSockFlag(so.s.u, o, unsafe.Pointer(&[]byte(v)[0]), len(v))
}

func (so *SocketOptions) setLinger(o C.SRT_SOCKOPT, v syscall.Linger) error {
	return cSetSockFlag(so.s.u, o, unsafe.Pointer(&v), int(unsafe.Sizeof(v)))
}
{{ range $enum := .Enums }}
type {{ $enum.GoName }} {{ $enum.Type }}

const ({{ range $value := $enum.Values }}
	{{ $enum.GoName }}{{ $value.GoName }} = {{ $enum.GoName }}(C.{{ $value }}){{ end }}
)
{{ end }}
{{ range $opt := .Options }}{{ if $opt.HasRead }}
func (so *SocketOptions) {{ $opt.GoFunctionName }}() ({{ $opt.GoType }}, error) {
	v, err := so.get{{ $opt.CFunctionName }}(C.{{ $opt.Name }})
	return {{ $opt.GoType }}(v), err
}
{{ end }}{{ if $opt.HasWrite }}
func (so *SocketOptions) Set{{ $opt.GoFunctionName }}(v {{ $opt.GoType }}) error {
	return so.set{{ $opt.CFunctionName }}(C.{{ $opt.Name }}, {{ $opt.Go2CType }}(v))
}
{{ end }}{{ end }}`,
		filename: "socket_option.go",
	},
	{
		content: `// Code generated by astisrt using internal/cmd/generate/options. DO NOT EDIT.
package astisrt

import (
	"fmt"
	"syscall"
)

type ConnectionOptions struct {
	c *Connection
}

func (c *Connection) Options() *ConnectionOptions {
	return &ConnectionOptions{c: c}
}

type ConnectionOption struct {
	do 		 func(s *Socket) error
	name 	 string
}

func applyConnectionOptions(s *Socket, opts []ConnectionOption) (err error) {
	for _, opt := range opts {
		if err = opt.do(s); err != nil {
			err = fmt.Errorf("astisrt: applying %s option failed: %w", opt.name, err)
			return
		}
	}
	return
}
{{ range $opt := .ConnectionOptions }}{{ if $opt.HasRead }}
func (co *ConnectionOptions) {{ $opt.GoFunctionName }}() ({{ $opt.GoType }}, error) {
	return co.c.s.Options().{{ $opt.GoFunctionName }}()
}
{{ end }}{{ if $opt.HasWrite }}
func (co *ConnectionOptions) Set{{ $opt.GoFunctionName }}(v {{ $opt.GoType }}) error {
	return co.c.s.Options().Set{{ $opt.GoFunctionName }}(v)
}

func With{{ $opt.GoFunctionName }}(v {{ $opt.GoType }}) ConnectionOption {
	return ConnectionOption{
		do: func(s *Socket) error { return s.Options().Set{{ $opt.GoFunctionName }}(v) },
		name: "{{ $opt.GoFunctionName }}",
	}
}
{{ end }}{{ end }}`,
		filename: "connection_option.go",
	},
}

func main() {
	dir, err := os.Getwd()
	if err != nil {
		log.Fatal(fmt.Errorf("main: getting working directory failed: %w", err))
	}

	opts, enums, err := options(dir)
	if err != nil {
		log.Fatal(fmt.Errorf("main: getting options failed: %w", err))
	}

	for _, tpl := range tpls {
		log.Printf("generating %s\n", tpl.filename)

		f, err := os.Create(filepath.Join(dir, "pkg", tpl.filename))
		if err != nil {
			log.Fatal(fmt.Errorf("main: creating file failed: %w", err))
		}
		defer f.Close()

		if err = template.Must(template.New("tmpl").Parse(tpl.content)).Execute(f, data{
			Enums:   enums,
			Options: opts,
		}); err != nil {
			log.Fatal(fmt.Errorf("main: executing template failed: %w", err))
		}
	}
}

type optionFilePosition int

const (
	optionFilePositionNone optionFilePosition = iota
	optionFilePositionList
	optionFilePositionListTable
	optionFilePositionEnum
)

func options(dir string) (opts []option, enums []enum, err error) {
	// Open doc
	var f *os.File
	if f, err = os.Open(filepath.Join(dir, "tmp", version, "src", "docs", "API", "API-socket-options.md")); err != nil {
		err = fmt.Errorf("main: opening doc failed: %w", err)
		return
	}
	defer f.Close()

	// Loop
	var p optionFilePosition
	var enumNames []string
	s := bufio.NewScanner(f)
scan:
	for s.Scan() {
		// Trim
		t := strings.TrimSpace(s.Text())

		// Switch on file position
		switch p {
		case optionFilePositionNone:
			// Update file position
			if strings.HasPrefix(t, "## List of Options") {
				p = optionFilePositionList
			} else if strings.HasPrefix(t, "### Enumeration Types Used in Options") {
				p = optionFilePositionEnum
			}
		case optionFilePositionEnum:
			if strings.HasPrefix(t, "# ") || strings.HasPrefix(t, "## ") || strings.HasPrefix(t, "### ") {
				p = optionFilePositionNone
			} else if matches := r3.FindAllStringSubmatch(t, -1); len(matches) > 0 && len(matches[0]) > 1 {
				enumNames = append(enumNames, matches[0][1])
			}
		case optionFilePositionList:
			// Update file position
			if strings.HasPrefix(t, "| :-") {
				p = optionFilePositionListTable
			}
		case optionFilePositionListTable:
			// We're done
			if t == "" {
				break scan
			}

			// Split
			split := strings.Split(t, "|")
			if len(split) < 9 {
				continue
			}

			// Create option
			opt := option{Dir: strings.TrimSpace(split[8])}

			// Match name
			matches := r1.FindAllStringSubmatch(split[1], -1)
			if len(matches) < 1 || len(matches[0]) < 2 {
				continue
			}
			opt.Name = matches[0][1]

			// Match type
			matches = r2.FindAllStringSubmatch(split[4], -1)
			if len(matches) < 1 || len(matches[0]) < 2 {
				continue
			}
			opt.Type = matches[0][1]

			// Append option
			opts = append(opts, opt)
		}
	}

	// Read header
	var b []byte
	if b, err = os.ReadFile(filepath.Join(dir, "tmp", version, "include", "srt", "srt.h")); err != nil {
		err = fmt.Errorf("main: reading header failed: %w", err)
		return
	}

	// Loop through enums
	for _, v := range enumNames {
		// Match
		matches := regexp.MustCompile(`(typedef )*enum `+v+`\n\{([^\}]*)`).FindAllStringSubmatch(string(b), -1)
		if len(matches) < 1 || len(matches[0]) < 3 {
			continue
		}

		// Create enum
		enum := enum{Name: v}

		// Get search
		if split := strings.Split(v, "_"); len(split) > 1 {
			enum.search = strings.Join(split[1:], "")
		}

		// Loop
		s := bufio.NewScanner(bytes.NewReader([]byte(matches[0][2])))
		for s.Scan() {
			// Trim text
			t := strings.TrimSpace(s.Text())
			if len(t) == 0 {
				continue
			}

			// Split
			split := strings.Split(t, "=")

			// Append value
			enum.Values = append(enum.Values, enumValue(strings.TrimSuffix(strings.TrimSpace(split[0]), ",")))
		}

		// Append enum
		enums = append(enums, enum)
	}

	// Loop through options
	for idxOpt, opt := range opts {
		// Loop through enums
		for idxEnum, enum := range enums {
			if strings.HasSuffix(opt.Name, "_"+enum.search) {
				enums[idxEnum].Type = opt.GoType()
				opts[idxOpt].goType = enum.GoName()
			}
		}
	}
	return
}
